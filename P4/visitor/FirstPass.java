//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */

public class FirstPass<R, A> implements GJVisitor<String, String> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //

/*-------------------------- GLOBAL CONSTANTS & FLAGS --------------------------*/
   Boolean INIT  = false;
   Boolean CREATE_GRAPH = false;
   Boolean INCREMENTED_CALL_STACKSIZE = false;
/*-------------------------- GLOBAL CONSTANTS & FLAGS --------------------------*/



/*-------------------------- GLOBAL VARS --------------------------*/
   public Vector<ProcedureNode> procedureList = new Vector<ProcedureNode>();

   ProcedureNode  currProcedure;
   BlockNode      currentBlock;

   Boolean  setLabel = false;
   String   currentLabel = null;

   Integer  ArgCounter = 0;
/*-------------------------- GLOBAL VARS --------------------------*/



/*-------------------------- FUNCTIONS --------------------------*/
   void createGraph(){
      for(int i = 0 ; i < procedureList.size() ; i++){
         currProcedure = procedureList.get(i);
         BlockNode block = currProcedure.enterBlock;
         while(block != null){
            currentBlock = block;
            BlockNode temp = block.successor;
            if(block.statement != null){
               CREATE_GRAPH = true;
               block.statement.f0.accept(this, null);
               CREATE_GRAPH = false; 
            }
            block = temp;
         }
      }
   }

   void RA(){
      for(int i = 0 ; i < procedureList.size() ; i++){
         currProcedure = procedureList.get(i);

         Boolean flag = false;
         do{
            flag = true;
            for(int j = 0 ; j < currProcedure.blockList.size() ; j++){
               BlockNode block = currProcedure.blockList.get(j);
               flag = flag && visit(block);
            }
         }while(!flag);

         for(int j = 0 ; j < currProcedure.blockList.size() ; j++){
            BlockNode block = currProcedure.blockList.get(j);
            for(Integer temp : block.out){
               if(!currProcedure.liveStart.containsKey(temp)){
                  currProcedure.liveStart.put(temp, j);
               }
            }
            for(Integer temp : block.in){
               currProcedure.liveEnd.put(temp, j);
            }
         }
         currProcedure.GetLiveIntervals();
         currProcedure.LinearScan();
      }
   }
   Boolean visit(BlockNode block){
      /* in'[n] <-- in[n] */
         Set<Integer> tempIN = new HashSet<Integer>();
         tempIN.addAll(block.in);

      /* out'[n] <-- out[n] */
         Set<Integer> tempOUT = new HashSet<Integer>();
         tempOUT.addAll(block.out);

      /* in[n] <-- use[n] U (out[n] - def[n]) */
         block.in.clear();
         block.in.addAll(block.use);
         Set<Integer> temp = new HashSet<Integer>();
         temp.addAll(block.out);
         temp.removeAll(block.def);
         block.in.addAll(temp);

      block.out.clear();
      if(block.successor!=null)block.out.addAll(block.successor.in);
      if(block.successorTwo!=null)block.out.addAll(block.successorTwo.in);

      if(tempIN.equals(block.in) && tempOUT.equals(block.out)){
         return true;
      }
      return false;
   }


   /*-- DEBUG PRINT --*/
   void printProcedures(){
      for(int i=0; i<procedureList.size(); i++){
         System.out.println("Procedure: " + procedureList.get(i).label);
         System.out.println("Args: " + procedureList.get(i).args);
         System.out.println("StackSpace: " + procedureList.get(i).stackSpace);
         System.out.println("CallArgs: " + procedureList.get(i).callArgs);
         printBlocks(procedureList.get(i));

         for(Interval inter : (procedureList.get(i)).liveIntervals){
            System.out.println("Temp: " + inter.temp + " Start: " + (inter.start+1) + " End: " + (inter.end+1));
         }

         System.out.println();

         for(Map.Entry<Integer,String> entry : (procedureList.get(i)).register.entrySet()){
            System.out.println("Temp: " + entry.getKey() + " Register: " + entry.getValue());
         }

         System.out.println();
      }
   }
   void printBlocks(ProcedureNode proc){
      for(int i = 0 ; i < proc.blockList.size() ; i++){
         BlockNode block = proc.blockList.get(i);
         if(block == null){
            return;
         }
         if(block.label!=null)System.out.println("Label: " + block.label);
         System.out.println("DEF: "+ block.def);
         System.out.println("USE: "+ block.use);
         System.out.println("IN: "+ block.in);
         System.out.println("OUT: "+ block.out);

         System.out.println();
      }
   }
/*-------------------------- FUNCTIONS --------------------------*/


   public String visit(NodeList n, String argu) {
      String _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public String visit(NodeListOptional n, String argu) {
      if ( n.present() ) {
         String _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public String visit(NodeOptional n, String argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public String visit(NodeSequence n, String argu) {
      String _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public String visit(NodeToken n, String argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public String visit(Goal n, String argu) {
      String _ret=null;

      INIT = true;
      /* CREATING PROCEDURE NODE */
      if(INIT){
         ProcedureNode main = new ProcedureNode();
            main.label = "MAIN"; main.args = 0; main.stackSpace = 0; main.callArgs = 0;
            BlockNode enterBlock = new BlockNode();
               enterBlock.statement = null;
               enterBlock.label = null;
               enterBlock.successor = null;
               enterBlock.successorTwo = null;
            main.enterBlock = enterBlock;
         currProcedure = main;
         procedureList.add(main);
         currentBlock = enterBlock;
      }
      /* CREATING PROCEDURE NODE */

      n.f0.accept(this, argu);//MAIN
      n.f1.accept(this, argu);//StmtList  
      n.f2.accept(this, argu);//END
      n.f3.accept(this, argu);//Procedures
      n.f4.accept(this, argu);//EOF
      INIT = false;

      createGraph();
      
      RA();


      //printProcedures();
      
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public String visit(StmtList n, String argu) {
      String _ret=null;
      n.f0.accept(this, "ADD_LABEL_TO_BLOCKNODE");
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public String visit(Procedure n, String argu) {
      String _ret=null;

      /* CREATING PROCEDURE NODE */
      if(INIT){
         INCREMENTED_CALL_STACKSIZE = false;
         ProcedureNode proc = new ProcedureNode();
            proc.label = n.f0.f0.toString(); proc.args = Integer.parseInt(n.f2.f0.toString()); 
            proc.stackSpace = 8; 
            if(proc.args>4)proc.stackSpace += proc.args-4;
            proc.callArgs = 0;
            
            BlockNode enterBlock = new BlockNode();
               enterBlock.statement = null;
               enterBlock.label = null;
               enterBlock.successor = null;
               enterBlock.successorTwo = null;
            proc.enterBlock = enterBlock;
         currProcedure = proc;
         procedureList.add(proc);
         currentBlock = enterBlock;
      }
      /* CREATING PROCEDURE NODE */

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public String visit(Stmt n, String argu) {
      String _ret=null;

      /* CREATING BLOCK */
      if(INIT){
         BlockNode newBlock = new BlockNode();
            newBlock.statement = n;
            newBlock.label = null;
            if(setLabel){
               newBlock.label = currentLabel;
               currProcedure.labelBlock.put(currentLabel, newBlock);
               setLabel = false;
            }
            newBlock.successor = null;
            newBlock.successorTwo = null;

            currProcedure.blockList.add(newBlock);
            currentBlock.successor = newBlock;
            currentBlock = newBlock;
      }
      /* CREATING BLOCK */

      n.f0.accept(this, argu);//The Statement

      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public String visit(NoOpStmt n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public String visit(ErrorStmt n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public String visit(CJumpStmt n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, "CJUMP");
      
      /* ADD DEFS AND USES */
         if(INIT){
            currentBlock.use.add(Integer.parseInt(n.f1.f1.f0.toString()));
         }
      /* ADD DEFS AND USES */

      /* CREATE GRAPH */
         if(CREATE_GRAPH){
            currentBlock.successorTwo = currProcedure.labelBlock.get(n.f2.f0.toString());
         }
      /* CREATE GRAPH */

      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public String visit(JumpStmt n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, "JUMP");

      /* CREATE GRAPH */
         if(CREATE_GRAPH){
            currentBlock.successor = currProcedure.labelBlock.get(n.f1.f0.toString());
         }
      /* CREATE GRAPH */

      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public String visit(HStoreStmt n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);

      /* ADD DEFS AND USES */
         if(INIT){
            currentBlock.use.add(Integer.parseInt(n.f1.f1.f0.toString()));
            currentBlock.use.add(Integer.parseInt(n.f3.f1.f0.toString()));
         }
      /* ADD DEFS AND USES */

      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public String visit(HLoadStmt n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);

      /* ADD DEFS AND USES */
         if(INIT){
            currentBlock.def.add(Integer.parseInt(n.f1.f1.f0.toString()));
            currentBlock.use.add(Integer.parseInt(n.f2.f1.f0.toString()));
         }
      /* ADD DEFS AND USES */

      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public String visit(MoveStmt n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, "USE");

      /* ADD DEFS AND USES */
         if(INIT){
            currentBlock.def.add(Integer.parseInt(n.f1.f1.f0.toString()));
         }
      /* ADD DEFS AND USES */
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public String visit(PrintStmt n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, "USE");
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public String visit(Exp n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public String visit(StmtExp n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      /* CREATING BLOCK */
      if(INIT){
         BlockNode newBlock = new BlockNode();
            newBlock.statement = null;
            newBlock.label = null;
            if(setLabel){
               newBlock.label = currentLabel;
               currProcedure.labelBlock.put(currentLabel, newBlock);
               setLabel = false;
            }
            newBlock.successor = null;
            newBlock.successorTwo = null;

            currProcedure.blockList.add(newBlock);
            currentBlock.successor = newBlock;
            currentBlock = newBlock;
      }
      /* CREATING BLOCK */

      n.f3.accept(this, "USE");//return statement
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public String visit(Call n, String argu) {
      String _ret=null;

      /*--- INC STKSZE ---*/
         if(INIT && !INCREMENTED_CALL_STACKSIZE){
            currProcedure.stackSpace += 10;
            INCREMENTED_CALL_STACKSIZE = true;
         }
      /*--- INC STKSZE ---*/

      n.f0.accept(this, argu);
      n.f1.accept(this, "USE");
      n.f2.accept(this, argu);
      ArgCounter = 0;
      n.f3.accept(this, "USE_AND_COUNT");
      n.f4.accept(this, argu);

      /*--- CallArgs ---*/
         if(INIT){
            currProcedure.callArgs = Math.max(currProcedure.callArgs,ArgCounter);
            if(ArgCounter>4){
               currProcedure.stackSpace += ArgCounter-4;
            }
         }
      /*--- CallArgs ---*/

      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public String visit(HAllocate n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, "USE");
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public String visit(BinOp n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);

      /* ADD DEFS AND USES */
         if(INIT){
            currentBlock.use.add(Integer.parseInt(n.f1.f1.f0.toString()));
         }
      /* ADD DEFS AND USES */

      n.f2.accept(this, "USE");
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public String visit(Operator n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public String visit(SimpleExp n, String argu) {
      String _ret=null;

      /* ADD DEFS AND USES */
      if(n.f0.which==0 && INIT && argu!=null && argu.equals("USE")){
         n.f0.accept(this, "USE");
      }
      /* ADD DEFS AND USES */

      n.f0.accept(this, "SIMPLE_EXP");
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public String visit(Temp n, String argu) {
      String _ret=null;

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);

      /* ADD DEFS AND USES */
         if(INIT && argu != null &&argu.equals("USE")){
            currentBlock.use.add(Integer.parseInt(n.f1.f0.toString()));
         }
         if(INIT && argu != null &&argu.equals("USE_AND_COUNT")){
            currentBlock.use.add(Integer.parseInt(n.f1.f0.toString()));
            ArgCounter++;
         }
      /* ADD DEFS AND USES */

      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public String visit(IntegerLiteral n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public String visit(Label n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);

      /* LABELLING BLOCKNODE */
         if(INIT && argu!=null && argu.equals("ADD_LABEL_TO_BLOCKNODE")){
            currentLabel = n.f0.toString();
            setLabel = true;
         }
      /* LABELLING BLOCKNODE */

      return _ret;
   }

}
