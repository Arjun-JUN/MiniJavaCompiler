//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;


/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */

/*------ Declaring "struct"s that we require ------*/
   class ClassMap{
      String name;
      String parent; // For extends
      HashMap<String, String>    variables   = new HashMap<>();
      HashMap<String, MethodMap> methods     = new HashMap<>();  
   }

   class MethodMap{
      String name;
      String parentClass;
      Vector<Para> parameters = new Vector<>();
      HashMap<String, String> variables  = new HashMap<>();
      String retType;  
   }

   class Para{
      String name;
      String type;
   }
/*------ Declaring "struct"s that we require END---*/


public class GJDepthFirst<R,A> implements GJVisitor<String,String> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //

   /*-------- Flags --------*/
      int flagVar = 0;/*
         0 = Class variables
         1 = Method variables    
      */
      int pass = 0;/*
         0 = for storing classes, method and check for redeclaration
         1 = typeCheck expressions; non declared var;
      */
   /*-------- Flags END ----*/


   /*-------- Global variables --------*/
      HashMap<String, ClassMap> AllClass = new HashMap<>();
      String currClass;
      String currMethod;
      Vector<String> expListGlobal = new Vector<String>();
   /*-------- Global variables END ----*/
   

/* -------- CUSTOM Functions ------------------------------------------------------------------ */
/* -------------------------------------------------------------------------------------------- */

   /*------ Error functions -------*/
      void throwTypeError(String arg){
         System.out.println("Type error");
         System.exit(0);
      }
      void symbolNotFound(String arg){
         System.out.println("Symbol not found");
         System.exit(0);
      }
   /*------ Error functions END ---*/


   /*------ for adding a new class ------*/
      boolean checkClass(String name){
         if(AllClass.containsKey(name)){
            return true;
         }
         else{
            return false;
         }
      }
      ClassMap addClass(String name, String parent){
         if(checkClass(name)){
            throwTypeError("redefinedClass");
         }
         ClassMap object = new ClassMap();
         object.name = name;
         object.parent = parent;
         AllClass.put(name,object);

         return object;
      }
   /*------ for adding a new class END --*/
      

   /*------ for adding a new Method ------*/
      boolean checkMethod(ClassMap p, String name){
         if(p.methods.containsKey(name)){
            return true;
         }
         else{
            return false;
         }
      }
      void addMethod(String pClass,MethodMap meth){
         ClassMap p = AllClass.get(pClass);
         if(checkMethod(p, meth.name)){
            throwTypeError("redefinedMethod");
         }
         p.methods.put(meth.name,meth);
      }
   /*------ for adding a new method END --*/


   /*------ for adding variables inside -------*/
      void addVarClass(String var, String typeVar, ClassMap obj){
         if(obj.variables.containsKey(var)){
            throwTypeError("redefinedVarClass");
         }
         obj.variables.put(var,typeVar);
      }
      void addVarMethod(String var, String typeVar, MethodMap obj){
         if(obj.variables.containsKey(var)){
            throwTypeError("redefinedVarMethod");
         }
         obj.variables.put(var,typeVar);
      }
   /*------ for adding variables inside END ---*/


   /*------ isValid Type -----*/
      boolean isValidType(String t){
         if(AllClass.containsKey(t) || t.equals("int") || t.equals("boolean") || t.equals("int[]")){
            return true;
         }
         return false;
      }
      void allValidTypes(){
         for(Map.Entry<String,ClassMap> field : AllClass.entrySet()){
            ClassMap cls = field.getValue();
            validTypesInClass(cls);
         }
      }
      void validTypesInClass(ClassMap ptr){
         if(ptr.variables != null){
            for(Map.Entry<String, String> field : ptr.variables.entrySet()){
               String type = field.getValue();
               if(!(isValidType(type)))symbolNotFound("non valid type in CLASS field");
            }
         }
         if(ptr.methods != null){
            for(Map.Entry<String, MethodMap> field : ptr.methods.entrySet()){
               MethodMap meth = field.getValue();
               validTypesInMethod(meth);
            }
         }
      }
      void validTypesInMethod(MethodMap meth){
         if(meth.name.equals("main")){
            return;
         }
         if(!isValidType(meth.retType))symbolNotFound("non valid return type in method");

         int n = 0;
         if(meth.parameters!=null) n = meth.parameters.size();
         for(int i = 0 ; i < n; i++){
            if(!isValidType(meth.parameters.get(i).type)){
               symbolNotFound("non valid type in method parameters");
            }
         }
         if(meth.variables != null){
            for(Map.Entry<String, String> field : meth.variables.entrySet()){
               String type = field.getValue();
               if(!(isValidType(type)))symbolNotFound("non valid type in method variables");
            }
         }
         
      }
   /*------ isValid Type -----*/


   /*------ Importing and overloading in extended Class -------*/
      void extendClasses(){
         for(Map.Entry<String,ClassMap> field : AllClass.entrySet()){
            ClassMap cls = field.getValue();
            extendClass(cls);
         }
      }
      void extendClass(ClassMap cls){
         ClassMap ptr = cls;
         while(ptr.parent!=null){
            if(!AllClass.containsKey(ptr.parent)){
               symbolNotFound("Parentclassnot found for class: "+cls.name);
            }
            ptr = AllClass.get(ptr.parent);
            if(ptr.variables != null){
               for(Map.Entry<String, String> field : ptr.variables.entrySet()){
                  String varname = field.getKey();
                  String type = field.getValue();
                  if(!(cls.variables.containsKey(varname)))cls.variables.put(varname,type);
               }
            }
            if(ptr.methods != null){
               for(Map.Entry<String, MethodMap> field : ptr.methods.entrySet()){
                  String name = field.getKey();
                  MethodMap meth = field.getValue();
                  if((cls.methods.containsKey(name))){
                     if(!sameSignature(meth, cls.methods.get(name))){
                        throwTypeError("overload in extendedClass");
                     }
                  }
                  else{
                     cls.methods.put(name,meth);
                  }
               }
            }
         }
      }
      boolean sameSignature(MethodMap m1, MethodMap m2){
         if(m1.variables.equals(m2.variables) && sameType(m1.retType,m2.retType)){
            if(m1.parameters.size() != m2.parameters.size()){
               return false;
            }
            int n = 0;
            if(m1.parameters!=null)n = m1.parameters.size();
            for(int i = 0 ; i < n; i++){
               if(((m1.parameters.get(i).name).equals(m2.parameters.get(i).name)) && ((m1.parameters.get(i).type).equals(m2.parameters.get(i).type))){
                  continue;
               }
               else{
                  return false;
               }
            }
            return true;
         }
         else{
            return false;
         }
      }
   /*------ Importing and overloading in extended Class END ---*/
    

   /*------ Checking cyclic Inheritance -------*/
      void checkCycle(){
         for(Map.Entry<String,ClassMap> field : AllClass.entrySet()){
            ClassMap cls = field.getValue();
            if(inCycle(cls)){
               throwTypeError("cycle");
            }
         }
      }
      boolean inCycle(ClassMap cls){
         ClassMap ptr = cls;
         HashMap<String, String> visited = new HashMap<>();
         while(ptr.parent != null){
            if(visited.containsKey(ptr.name)){
               return true;
            }
            visited.put(ptr.name,"true");
            ptr = AllClass.get(ptr.parent);
         }
         return false;
      }
   /*------ Checking cyclic Inheritance END ---*/


   /*------ Get Type of variable -------*/
      String getType(String name){
         ClassMap cls   = AllClass.get(currClass);
         MethodMap meth = cls.methods.get(currMethod);
         if(meth.variables.containsKey(name)){
            return meth.variables.get(name);
         }
         if(cls.variables.containsKey(name)){
            return cls.variables.get(name);
         }
         symbolNotFound("var: "+name+" not found");
         return null;
      }
      ClassMap getClass(String name){
         if(name.equals("this")){
            return AllClass.get(currClass);
         }
         if(!(AllClass.containsKey(name))){
            symbolNotFound("getting Class");
         }
         ClassMap cls = AllClass.get(name);
         return cls;
      }
   /*------ Get Type of variable END ---*/


   /*------ Checking Signature of method call -------*/
      void checkMethodCall(MethodMap meth){
         if(meth.parameters.size() != expListGlobal.size()){
            throwTypeError("method sign not matching1");
         }
         int n = 0;
         if(meth.parameters!=null) n = meth.parameters.size();
         for(int i = 0 ; i < n; i++){
            String t1 = meth.parameters.get(i).type;
            String t2 = expListGlobal.get(i);
            if(!(t1.equals(t2))){
               if(AllClass.containsKey(t1) && AllClass.containsKey(t2)){
                  ClassMap c1 = AllClass.get(t1);
                  ClassMap c2 = AllClass.get(t2);
                  if(!isClassExtended(c1,c2)){
                     throwTypeError("Method call: Two classes");
                  }
               }
               else{
                  throwTypeError("Method call: non class compare");
               }
            }
         }
      }
      boolean isClassExtended(ClassMap parent, ClassMap extended){
         ClassMap ptr = extended;
         while(ptr.parent != null){
            if((ptr.parent).equals(parent.name)){
               return true;
            }
            ptr = AllClass.get(ptr.parent);
         }
         return false;

      }
   /*------ Checking Signature of method call -------*/

   
   /*------ EqualType -------*/
      boolean sameType(String t1, String t2){
         if(t1.equals(t2)){
            return true;
         }
         if(AllClass.containsKey(t1) && AllClass.containsKey(t2)){
            return isClassExtended(AllClass.get(t1), AllClass.get(t2));
         }
         return false;
      }
   /*------ EqualType -------*/


/* -------- CUSTOM Functions END -------------------------------------------------------------- */
/* -------------------------------------------------------------------------------------------- */


   public String visit(NodeList n, String argu) {
      String _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public String visit(NodeListOptional n, String argu) {
      if ( n.present() ) {
         String _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public String visit(NodeOptional n, String argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public String visit(NodeSequence n, String argu) {
      String _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public String visit(NodeToken n, String argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public String visit(Goal n, String argu) {
      String _ret=null;

      /*----- First pass -----*/
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      /*----- First pass --w---*/

      /*----- Extended classes -----*/
      checkCycle();
      extendClasses();
      allValidTypes();
      /*----- Extended classes -----*/

      pass = 1;

      /*----- Second pass -----*/
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      /*----- Second pass -----*/

      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public String visit(MainClass n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      String cls = n.f1.accept(this, argu);
      
      /*------ AddClass ------*/
        if (pass == 0) {
            addClass(cls,null);
        }
      /*------ AddClass ------*/

      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      n.f10.accept(this, argu);
      

      /*------ Add main method ------*/
        if (pass == 0) {
            MethodMap object = new MethodMap();
            object.name = "main";
            object.parentClass = cls;
            Para p = new Para();
            p.type = "String[]";

            p.name = n.f11.accept(this, argu);

            object.parameters.add(p);
            object.retType = "void";
            addMethod(cls, object);
        }
      /*------ Add main method ------*/

      n.f12.accept(this, argu);
      n.f13.accept(this, argu);
      n.f14.accept(this, argu);
      n.f15.accept(this, argu);
      n.f16.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public String visit(TypeDeclaration n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public String visit(ClassDeclaration n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);

      String cls = n.f1.accept(this, argu);

      currClass = cls;

      /*------ AddClass ------*/
        if (pass == 0) {
            addClass(cls,null);
        }
      /*------ AddClass ------*/

      n.f2.accept(this, argu);
      n.f3.accept(this, cls);//adding variables
      n.f4.accept(this, cls);//adding methods
      n.f5.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public String visit(ClassExtendsDeclaration n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);

      String cls = n.f1.accept(this, argu);

      currClass = cls;

      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      
      /*------ AddClass ------*/
        if (pass == 0) {
            addClass(cls,n.f3.f0.tokenImage);
        }
      /*------ AddClass ------*/



      n.f4.accept(this, argu);
      n.f5.accept(this, cls);//adding variables
      n.f6.accept(this, cls);//adding methods
      n.f7.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public String visit(VarDeclaration n, String scope) {
      String _ret=null;

      String typeVar = n.f0.accept(this, scope);
      n.f1.accept(this, scope);
      n.f2.accept(this, scope);

      /*---- Adding to the corresponding scope ----*/
         if (pass == 0) {
            if(flagVar == 0){//class variables
               ClassMap temp = AllClass.get(scope);
               addVarClass(n.f1.f0.tokenImage,typeVar,temp);
            }
            if(flagVar == 1){//method variables
               ClassMap  currC = AllClass.get(currClass);
               MethodMap temp  = currC.methods.get(scope);
               addVarMethod(n.f1.f0.tokenImage,typeVar,temp);
            }
         }
      /*---- Adding to the corresponding scope ----*/

      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public String visit(MethodDeclaration n, String pclass) {
      String _ret=null;

      n.f0.accept(this, pclass);

      String retType = n.f1.accept(this, pclass);// return type
      String name    = n.f2.accept(this, pclass);// method name
      
      currMethod = name;

      if (pass == 0) {
      /*------ Creating MethodMap ------*/
         MethodMap meth = new MethodMap();
         meth.retType = retType;
         meth.name = name;
         meth.parentClass = pclass;
      /*------ Creating MethodMap ------*/

      /*------ Adding the method to Class ------*/
         addMethod(pclass,meth);
      /*------ Adding the method to Class ------*/
      }

      n.f3.accept(this, pclass);
      n.f4.accept(this, name);// parameters will be added
      n.f5.accept(this, pclass);
      n.f6.accept(this, pclass);

         flagVar = 1;
      n.f7.accept(this, name);// variables
         flagVar = 0;

      n.f8.accept(this, pclass);
      n.f9.accept(this, pclass);
      String returnedType = n.f10.accept(this, pclass);

      if(pass==1){
         if(!sameType(retType,returnedType)){
            throwTypeError("return type not matching");
         }
      }

      n.f11.accept(this, pclass);
      n.f12.accept(this, pclass);
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public String visit(FormalParameterList n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public String visit(FormalParameter n, String m) {
      String _ret=null;

      String type = n.f0.accept(this, m);
      String name = n.f1.accept(this, m);

      if (pass == 0) {
      /*----- Getting Method to add para to -----*/
         ClassMap tmp = AllClass.get(currClass);
         MethodMap meth = tmp.methods.get(m);

         Para p = new Para();
         p.type = type;
         p.name = name;
      /*----- Getting Method to add para to -----*/  

      /*------ adding ------*/
         meth.parameters.add(p);
         addVarMethod(p.name,p.type,meth);
      /*------ adding ------*/
      }
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public String visit(FormalParameterRest n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public String visit(Type n, String argu) {
      String _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public String visit(ArrayType n, String argu) {
      String _ret="int[]";
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public String visit(BooleanType n, String argu) {
      String _ret="boolean";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public String visit(IntegerType n, String argu) {
      String _ret="int";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | DoStatement()
    *       | PrintStatement()
    */
   public String visit(Statement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public String visit(Block n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public String visit(AssignmentStatement n, String argu) {
      String _ret=null;

      String var = 
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);

      String expType = 
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      
      /*------ TypeCheck ------*/
         if (pass == 1){
            String varType = getType(var);
            if(!(sameType(varType,expType))){
               throwTypeError("assignment");
            }
         }
      /*------ TypeCheck ------*/

      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public String visit(ArrayAssignmentStatement n, String argu) {
      String _ret=null;

      String var =
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String expType1 =
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      String expType2 =
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);

      /*------ TypeCheck ------*/
         if (pass == 1){
            String varType = getType(var);
            if(!(varType.equals("int[]"))){
               throwTypeError("arr assignment1");
            }
            if(!(expType1.equals("int"))){
               throwTypeError("arr assignment2");
            }
            if(!(expType2.equals("int"))){
               throwTypeError("arr assignment3");
            }
         }
      /*------ TypeCheck ------*/

      return _ret;
   }

   /**
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public String visit(IfStatement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public String visit(IfthenStatement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String expType = 
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      /*------ TypeCheck ------*/
         if (pass == 1){
            if(!(expType.equals("boolean"))){
               throwTypeError("ifthen");
            }
         }
      /*------ TypeCheck ------*/

      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public String visit(IfthenElseStatement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String expType =
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);

      /*------ TypeCheck ------*/
         if (pass == 1){
            if(!(expType.equals("boolean"))){
               throwTypeError("ifthenelse");
            }
         }
      /*------ TypeCheck ------*/

      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public String visit(WhileStatement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String expType =
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      /*------ TypeCheck ------*/
         if (pass == 1){
            if(!(expType.equals("boolean"))){
               throwTypeError("while");
            }
         }
      /*------ TypeCheck ------*/

      return _ret;
   }

   /**
    * f0 -> "do"
    * f1 -> Statement()
    * f2 -> "while"
    * f3 -> "("
    * f4 -> Expression()
    * f5 -> ")"
    * f6 -> ";"
    */
   public String visit(DoStatement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      String expType =
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);

      /*------ TypeCheck ------*/
         if (pass == 1){
            if(!(expType.equals("boolean"))){
               throwTypeError("dowhile");
            }
         }
      /*------ TypeCheck ------*/

      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public String visit(PrintStatement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String expType =
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      /*------ TypeCheck ------*/
         if (pass == 1){
            if(!(expType.equals("int"))){
               throwTypeError("print");
            }
         }
      /*------ TypeCheck ------*/

      return _ret;
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | AddExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public String visit(Expression n, String argu) {
      String _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public String visit(AndExpression n, String argu) {
      String _ret="boolean";
      String t1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String t2 = n.f2.accept(this, argu);
      if(pass==1 && !(t1.equals(t2) && t1.equals("boolean"))){
         throwTypeError("&&");
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   public String visit(OrExpression n, String argu) {
      String _ret="boolean";
      String t1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String t2 = n.f2.accept(this, argu);
      if(pass==1 && !(t1.equals(t2) && t1.equals("boolean"))){
         throwTypeError("||");
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   public String visit(CompareExpression n, String argu) {
      String _ret="boolean";
      String t1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String t2 = n.f2.accept(this, argu);
      if(pass==1 && !(t1.equals(t2) && t1.equals("int"))){
         throwTypeError("<=");
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   public String visit(neqExpression n, String argu) {
      String _ret="boolean";
      String t1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String t2 = n.f2.accept(this, argu);
      if(pass==1 && !(sameType(t1,t2) && sameType(t2,t1))){
         throwTypeError("!=");
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public String visit(AddExpression n, String argu) {
      String _ret="int";
      String t1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String t2 = n.f2.accept(this, argu);
      if(pass==1 && !(t1.equals(t2) && t1.equals("int"))){
         throwTypeError("+");
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public String visit(MinusExpression n, String argu) {
      String _ret="int";
      String t1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String t2 = n.f2.accept(this, argu);
      if(pass==1 && !(t1.equals(t2) && t1.equals("int"))){
         throwTypeError("-");
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public String visit(TimesExpression n, String argu) {
      String _ret="int";
      String t1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String t2 = n.f2.accept(this, argu);
      if(pass==1 && !(t1.equals(t2) && t1.equals("int"))){
         throwTypeError("*");
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   public String visit(DivExpression n, String argu) {
      String _ret="int";
      String t1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String t2 = n.f2.accept(this, argu);
      if(pass==1 && !(t1.equals(t2) && t1.equals("int"))){
         throwTypeError("/");
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public String visit(ArrayLookup n, String argu) {
      String _ret="int";
      String t1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String t2 = n.f2.accept(this, argu);
      if(pass==1 && !(t2.equals("int") && t1.equals("int[]"))){
         throwTypeError("arr access");
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public String visit(ArrayLength n, String argu) {
      String _ret="int";
      String t1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      if(pass==1 && !(t1.equals("int[]"))){
         throwTypeError("arr length");
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public String visit(MessageSend n, String argu) {
      String _ret = null;
      String name =
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String methName =
      n.f2.accept(this, null);
      n.f3.accept(this, argu);
      n.f4.accept(this, "0");
      n.f5.accept(this, argu);

      /*------ Type check ------ */
         if(pass == 1){
            ClassMap cls = getClass(name);
            if(checkMethod(cls,methName)){
               checkMethodCall(cls.methods.get(methName));
               _ret=cls.methods.get(methName).retType;
            }
            else{
               symbolNotFound("method not found");
            }
            expListGlobal.clear();
         }
      /*------ Type check ------ */


      return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public String visit(ExpressionList n, String argu) {
      String _ret=null;
      String expType =
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);

      /*---- Adding to global explist ----*/
         if(pass==1) expListGlobal.add(0,expType);
      /*---- Adding to global explist ----*/

      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public String visit(ExpressionRest n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      String expType =
      n.f1.accept(this, argu);
      
      /*---- Adding to global explist ----*/
         if(pass==1) expListGlobal.add(expType);
      /*---- Adding to global explist ----*/

      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public String visit(PrimaryExpression n, String argu) {
      String _ret = n.f0.accept(this, "0");
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public String visit(IntegerLiteral n, String argu) {
      String _ret="int";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "true"
    */
   public String visit(TrueLiteral n, String argu) {
      String _ret="boolean";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "false"
    */
   public String visit(FalseLiteral n, String argu) {
      String _ret="boolean";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public String visit(Identifier n, String argu) {
      String _ret = n.f0.tokenImage;
      n.f0.accept(this, argu);
      if(argu!=null){
         if (argu.equals("0") && pass == 1){
            _ret = getType(_ret);
         }
      }
      return _ret;
   }

   /**
    * f0 -> "this"
    */
   public String visit(ThisExpression n, String argu) {
      String _ret = currClass;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public String visit(ArrayAllocationExpression n, String argu) {
      String _ret="int[]";
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String t = n.f3.accept(this, argu);
      if(pass==1 && !(t.equals("int"))){
         throwTypeError(t);
      }
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public String visit(AllocationExpression n, String argu) {
      n.f0.accept(this, argu);
      String _ret = n.f1.accept(this, null);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public String visit(NotExpression n, String argu) {
      String _ret="boolean";
      n.f0.accept(this, argu);
      String t = n.f1.accept(this, argu);
      if(pass==1 && !(t.equals("boolean"))){
         throwTypeError("! exp");
      }
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public String visit(BracketExpression n, String argu) {
      n.f0.accept(this, argu);
      String _ret = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( IdentifierRest() )*
    */
   public String visit(IdentifierList n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public String visit(IdentifierRest n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }
}