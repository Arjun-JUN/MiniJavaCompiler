//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;


/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */

/*------ Declaring "struct"s that we require ------*/
   class ClassMap{
      String name;
      String parent; // For extends
      HashMap<String, String>    variables   = new HashMap<>();
      HashMap<String, MethodMap> methods     = new HashMap<>();  

      Vector<String> methodList = new Vector<>();
      Vector<String> varList = new Vector<>();
   }

   class MethodMap{
      String name;
      String parentClass;
      Vector<Para> parameters = new Vector<>();
      HashMap<String, String> variables  = new HashMap<>();
      String retType;  

      MethodDeclaration NODE;
   }

   class Para{
      String name;
      String type;
   }
/*------ Declaring "struct"s that we require END---*/


public class GJDepthFirstCopy<R,A> implements GJVisitor<String,String> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //

   /*-------- Flags --------*/
      int flagVar = 0;/*
         0 = Class variables
         1 = Method variables    
      */
      int pass = 0;/*
         0 = for storing classes, method and check for redeclaration
         1 = typeCheck expressions; non declared var;
         2 = MICRO IR;
      */
   /*-------- Flags END ----*/


   /*-------- Global variables --------*/
      HashMap<String, ClassMap> AllClass = new HashMap<>();
      String currClass;
      String currMethod;
      Vector<String> expListGlobal = new Vector<String>();
   /*-------- Global variables END ----*/
   

/* -------- CUSTOM Functions ------------------------------------------------------------------ */
/* -------------------------------------------------------------------------------------------- */

   /*------ Error functions -------*/
      void throwTypeError(String arg){
      }
      void symbolNotFound(String arg){
      }
   /*------ Error functions END ---*/


   /*------ for adding a new class ------*/
      boolean checkClass(String name){
         if(AllClass.containsKey(name)){
            return true;
         }
         else{
            return false;
         }
      }
      ClassMap addClass(String name, String parent){
         if(checkClass(name)){
            throwTypeError("redefinedClass");
         }
         ClassMap object = new ClassMap();
         object.name = name;
         object.parent = parent;
         AllClass.put(name,object);

         return object;
      }
   /*------ for adding a new class END --*/
      

   /*------ for adding a new Method ------*/
      boolean checkMethod(ClassMap p, String name){
         if(p.methods.containsKey(name)){
            return true;
         }
         else{
            return false;
         }
      }
      void addMethod(String pClass,MethodMap meth){
         ClassMap p = AllClass.get(pClass);
         if(checkMethod(p, meth.name)){
            throwTypeError("redefinedMethod");
         }
         p.methods.put(meth.name,meth);
      }
   /*------ for adding a new method END --*/


   /*------ for adding variables inside -------*/
      void addVarClass(String var, String typeVar, ClassMap obj){
         if(obj.variables.containsKey(var)){
            throwTypeError("redefinedVarClass");
         }
         obj.variables.put(var,typeVar);
      }
      void addVarMethod(String var, String typeVar, MethodMap obj){
         if(obj.variables.containsKey(var)){
            throwTypeError("redefinedVarMethod");
         }
         obj.variables.put(var,typeVar);
      }
   /*------ for adding variables inside END ---*/


   /*------ isValid Type -----*/
      boolean isValidType(String t){
         if(AllClass.containsKey(t) || t.equals("int") || t.equals("boolean") || t.equals("int[]")){
            return true;
         }
         return false;
      }
      void allValidTypes(){
         for(Map.Entry<String,ClassMap> field : AllClass.entrySet()){
            ClassMap cls = field.getValue();
            validTypesInClass(cls);
         }
      }
      void validTypesInClass(ClassMap ptr){
         if(ptr.variables != null){
            for(Map.Entry<String, String> field : ptr.variables.entrySet()){
               String type = field.getValue();
               if(!(isValidType(type)))symbolNotFound("non valid type in CLASS field");
            }
         }
         if(ptr.methods != null){
            for(Map.Entry<String, MethodMap> field : ptr.methods.entrySet()){
               MethodMap meth = field.getValue();
               validTypesInMethod(meth);
            }
         }
      }
      void validTypesInMethod(MethodMap meth){
         if(meth.name.equals("main")){
            return;
         }
         if(!isValidType(meth.retType))symbolNotFound("non valid return type in method");

         int n = 0;
         if(meth.parameters!=null) n = meth.parameters.size();
         for(int i = 0 ; i < n; i++){
            if(!isValidType(meth.parameters.get(i).type)){
               symbolNotFound("non valid type in method parameters");
            }
         }
         if(meth.variables != null){
            for(Map.Entry<String, String> field : meth.variables.entrySet()){
               String type = field.getValue();
               if(!(isValidType(type)))symbolNotFound("non valid type in method variables");
            }
         }
         
      }
   /*------ isValid Type -----*/


   /*------ Importing and overloading in extended Class -------*/
      void extendClasses(){
         for(Map.Entry<String,ClassMap> field : AllClass.entrySet()){
            ClassMap cls = field.getValue();
            extendClass(cls);
         }
      }
      void extendClass(ClassMap cls){
         ClassMap ptr = cls;

         Vector<String> methodList = new Vector<>();
         Vector<String> varList = new Vector<>();  
         if(ptr.variables != null){
            for(Map.Entry<String, String> field : ptr.variables.entrySet()){
               String varname = field.getKey();
               varList.add(varname);
            }
         }
         if(ptr.methods != null){
            for(Map.Entry<String, MethodMap> field : ptr.methods.entrySet()){
               String name = field.getKey();
               methodList.add(name);
            }
         }

         while(ptr.parent!=null){
            if(!AllClass.containsKey(ptr.parent)){
               symbolNotFound("Parentclassnot found for class: "+cls.name);
            }
            ptr = AllClass.get(ptr.parent);
            if(ptr.variables != null){
               for(Map.Entry<String, String> field : ptr.variables.entrySet()){
                  String varname = field.getKey();
                  varList.add(varname);
                  String type = field.getValue();
                  if(!(cls.variables.containsKey(varname)))cls.variables.put(varname,type);
               }
            }
            if(ptr.methods != null){
               for(Map.Entry<String, MethodMap> field : ptr.methods.entrySet()){
                  String name = field.getKey();
                  methodList.add(name);
                  MethodMap meth = field.getValue();
                  if((cls.methods.containsKey(name))){
                     if(!sameSignature(meth, cls.methods.get(name))){
                        throwTypeError("overload in extendedClass");
                     }
                  }
                  else{
                     cls.methods.put(name,meth);
                  }
               }
            }
         }
         HashMap <String,String> doneMethod = new HashMap<>();
         for(int i = methodList.size()-1 ; i >= 0 ; i--){
            if(!doneMethod.containsKey(methodList.get(i))){cls.methodList.add(methodList.get(i));}
            doneMethod.put(methodList.get(i),"true");
         }
         HashMap <String,String> done = new HashMap<>();
         for(int i = varList.size()-1 ; i >= 0 ; i--){
            if(!done.containsKey(varList.get(i))){cls.varList.add(varList.get(i));}
            done.put(varList.get(i),"true");
         }
      }
      boolean sameSignature(MethodMap m1, MethodMap m2){
         if(m1.variables.equals(m2.variables) && sameType(m1.retType,m2.retType)){
            if(m1.parameters.size() != m2.parameters.size()){
               return false;
            }
            int n = 0;
            if(m1.parameters!=null)n = m1.parameters.size();
            for(int i = 0 ; i < n; i++){
               if(((m1.parameters.get(i).name).equals(m2.parameters.get(i).name)) && ((m1.parameters.get(i).type).equals(m2.parameters.get(i).type))){
                  continue;
               }
               else{
                  return false;
               }
            }
            return true;
         }
         else{
            return false;
         }
      }
   /*------ Importing and overloading in extended Class END ---*/
    

   /*------ Checking cyclic Inheritance -------*/
      void checkCycle(){
         for(Map.Entry<String,ClassMap> field : AllClass.entrySet()){
            ClassMap cls = field.getValue();
            if(inCycle(cls)){
               throwTypeError("cycle");
            }
         }
      }
      boolean inCycle(ClassMap cls){
         ClassMap ptr = cls;
         HashMap<String, String> visited = new HashMap<>();
         while(ptr.parent != null){
            if(visited.containsKey(ptr.name)){
               return true;
            }
            visited.put(ptr.name,"true");
            ptr = AllClass.get(ptr.parent);
         }
         return false;
      }
   /*------ Checking cyclic Inheritance END ---*/


   /*------ Get Type of variable -------*/
      String getType(String name){
         ClassMap cls   = AllClass.get(currClass);
         MethodMap meth = cls.methods.get(currMethod);
         if(meth.variables.containsKey(name)){
            return meth.variables.get(name);
         }
         if(cls.variables.containsKey(name)){
            return cls.variables.get(name);
         }
         symbolNotFound("var: "+name+" not found");
         return null;
      }
      ClassMap getClass(String name){
         if(name.equals("this")){
            return AllClass.get(currClass);
         }
         if(!(AllClass.containsKey(name))){
            symbolNotFound("getting Class");
         }
         ClassMap cls = AllClass.get(name);
         return cls;
      }
   /*------ Get Type of variable END ---*/


   /*------ Checking Signature of method call -------*/
      void checkMethodCall(MethodMap meth){
         if(meth.parameters.size() > expListGlobal.size()){
            throwTypeError("method sign not matching1");
         }
         int n = 0;
         if(meth.parameters!=null) n = meth.parameters.size();
         for(int i = n ; i > 0; i--){
            String t1 = meth.parameters.get(n-i).type;
            String t2 = expListGlobal.get(expListGlobal.size()-i);
            if(!(t1.equals(t2))){
               if(AllClass.containsKey(t1) && AllClass.containsKey(t2)){
                  ClassMap c1 = AllClass.get(t1);
                  ClassMap c2 = AllClass.get(t2);
                  if(!isClassExtended(c1,c2)){
                     throwTypeError("Method call: Two classes");
                  }
               }
               else{
                  throwTypeError("Method call: non class compare");
               }
            }
         }
      }
      boolean isClassExtended(ClassMap parent, ClassMap extended){
         ClassMap ptr = extended;
         while(ptr.parent != null){
            if((ptr.parent).equals(parent.name)){
               return true;
            }
            ptr = AllClass.get(ptr.parent);
         }
         return false;

      }
   /*------ Checking Signature of method call -------*/

   
   /*------ EqualType -------*/
      boolean sameType(String t1, String t2){
         if(t1.equals(t2)){
            return true;
         }
         if(AllClass.containsKey(t1) && AllClass.containsKey(t2)){
            return isClassExtended(AllClass.get(t1), AllClass.get(t2));
         }
         return false;
      }
   /*------ EqualType -------*/

   /*------ Printing -------*/
      void printmeth(MethodMap method){
         System.out.println("  name: " +  method.name + "->" + method.retType + "\n  inClass: " + method.parentClass);
         System.out.println("  parameters:");
         int n = 0;
         if(method.parameters!=null)n = method.parameters.size();
         for(int i = 0 ; i < n; i++)
         {
            System.out.println("    "+method.parameters.get(i).name+":"+method.parameters.get(i).type);
         }
         System.out.println("  variables:");
         if(method.variables!=null)
         {
            for(Map.Entry<String,String> field : method.variables.entrySet())
            {
               String varname = field.getKey();
               String type = field.getValue();
               System.out.println("    " + varname + ": " + type);
            }
         }
         
      }
      public void print(){
         for(Map.Entry<String,ClassMap> field : AllClass.entrySet())
         {
            String varname = field.getKey();
            ClassMap cls = field.getValue();
            System.out.println("\nCLASS: " + varname);
            System.out.println("ParentCLASS: " + cls.parent);
            System.out.println("FIELDS:");
            if(cls.variables!=null)
            {
               for(Map.Entry<String,String> fi : cls.variables.entrySet())
               {
                  String varnam = fi.getKey();
                  String typ = fi.getValue();
                  System.out.println("  "+varnam + ": " + typ);
               }
            }
            System.out.println("METHODS:");
            for(Map.Entry<String,MethodMap> fiel : cls.methods.entrySet())
            {
               printmeth(fiel.getValue());
               System.out.println("");
            }
            System.out.println("");
         }
      }
   /*------ Printing -------*/

/* -------- CUSTOM Functions END -------------------------------------------------------------- */
/* -------------------------------------------------------------------------------------------- */

/*----------------------------------------------------------------------------- */
/* - - - - - - - - - - - - - MICRO IR CUSTOM FUNCTIONS & VARS - - - - - - - - - */
/*----------------------------------------------------------------------------- */

   
   /*-------- Global variables --------*/
      int tempCounter = -1;
      int DEBUGFLAG = 0;
      int labelCounter = 0;
      HashMap<String,String> runTimeType = new HashMap<>();
   /*-------- Global variables --------*/


// A: 0  0 funcA1
//       1 funcA2
//    1  vA1
//    2  vA2
//    3  vA3

// B: 0  0 funcA1
//       1 funcA2 
//       2 funcB1
//    1  vA1
//    2  vA2
//    3  vA3
//    4  vB1

// C: 0  0 funcA1
//       1 funcA2
//       2 funcB1
//       3 funcC1
//    1  vA1
//    2  vA2
//    3  vA3
//    4  vB1
//    5  vC1


   /*------------ NEW ALLOC -------------*/
      void hallocate(int size){
         System.out.println("MOVE TEMP "+ Integer.toString((tempCounter+2))  +" "+Integer.toString(size));
         System.out.println("MOVE TEMP "+ Integer.toString((tempCounter+1))  +" HALLOCATE TEMP "+Integer.toString((tempCounter+2)));
         System.out.println("MOVE TEMP "+ Integer.toString((tempCounter+0))  +" TEMP "+Integer.toString((tempCounter+1)));
      }
      void createNewTable(String name){
         ClassMap cls = AllClass.get(name);

         /*------ CREATE CLASSTABLE ------*/
         tempCounter++;
            int classTableSize = (cls.variables.size()+1)*4;
            hallocate(classTableSize);

            /*------ CREATE METHODTABLE ------*/
            tempCounter++;
               int methodTableSize = cls.methods.size()*4;
               hallocate(methodTableSize);//temp 0 = methodTable

               int index = 0;
               for(int i = 0 ; i < cls.methodList.size() ; i++){
                  MethodMap meth = cls.methods.get(cls.methodList.get(i));
                  System.out.println("MOVE TEMP "+Integer.toString((tempCounter+1))+" "+name+"_NVK_"+meth.name);
                  System.out.println("HSTORE TEMP "+Integer.toString((tempCounter+0))+" "+Integer.toString(index)+" TEMP "+Integer.toString((tempCounter+1)));
                  index += 4;
               }
            tempCounter--;
            /*------ CREATE METHODTABLE ------*/

            index = 0;
            System.out.println("HSTORE TEMP "+Integer.toString((tempCounter+0))+" 0 TEMP "+Integer.toString((tempCounter+1)));
            /* PUT METHTABLE IN CLASSTABLE [0] */

            for(int i = 0 ; i < cls.varList.size() ; i++){
               index+=4;
               System.out.println("MOVE TEMP "+Integer.toString((tempCounter+1))+" 0");
               System.out.println("HSTORE TEMP "+Integer.toString((tempCounter+0))+" "+Integer.toString(index)+" TEMP "+Integer.toString((tempCounter+1)));
            }/* PUT VARS IN CLASSTABLE [i] */
         tempCounter--;
         /*------ CREATE CLASSTABLE ------*/
      }
   /*------------ NEW ALLOC -------------*/

   /*------------ GET OFFSET OF CURRENT METHOD -------------*/
      int getOffsetMethod(String className, String methodName){
         if(!AllClass.containsKey(className) && DEBUGFLAG==1){
            System.out.print("Class not found 1001: "+className);
            return -1;
         }
         ClassMap cls = AllClass.get(className);
         int index = 0;
         for(int i = 0 ; i < cls.methodList.size() ; i++){
            String meth = cls.methodList.get(i);
            if(meth.equals(methodName)){
               return index;
            }
            index += 4;
         }
         return -1;
      }
   /*------------ GET OFFSET OF CURRENT METHOD -------------*/

   /*------------ PRINT ALL METHODS IN MICRO IR ---------------*/
      void MicroIRAllMethods(){
         for(Map.Entry<String,ClassMap> field : AllClass.entrySet()){
            ClassMap cls = field.getValue();
            MicroIRClass(cls);
         }
      }
      void MicroIRClass(ClassMap cls){
         for(Map.Entry<String,MethodMap> field : cls.methods.entrySet()){
            MethodMap meth = field.getValue();
            MicroIRMethod(meth,cls.name);
         }
      }
      void MicroIRMethod(MethodMap meth, String className){
         currClass = className;
         currMethod = meth.name;
         tempCounter = meth.variables.size();
         if(meth.name.equals("main"))return;
         meth.NODE.accept(this,className);
      }
   /*------------ PRINT ALL METHODS IN MICRO IR ---------------*/
   
   /*------------ GET TEMP OF ID ---------------*/
      int getTempOfID(String id){
         ClassMap cls = AllClass.get(currClass);
         MethodMap meth = cls.methods.get(currMethod);
         int index = 0;

         HashMap <String,String> done = new HashMap<>();

         if(meth.parameters != null){
            for(; index < meth.parameters.size(); index++){
               String var = meth.parameters.get(index).name;
               done.put(var,"true");
               if(var.equals(id)){
                  return index+1;
               }
            }
         }
         if(meth.variables.containsKey(id)){
            index++;
            for(Map.Entry<String,String> field : meth.variables.entrySet()){
               String var = field.getKey();
               if(var.equals(id)){
                  return index;
               }
               if(!done.containsKey(var))index ++;
            }
         }
         return -1;
      }
      int getOffsetVar(String id){
         ClassMap cls = AllClass.get(currClass);
         if(cls.variables.containsKey(id)){
            int index = 4;
            for(int i = 0 ; i < cls.varList.size() ; i++){
               String var = cls.varList.get(i);
               if(var.equals(id)){
                  return index;
               }
               index += 4;
            }
         }
         return -1;
      }
   /*------------ GET TEMP OF ID ---------------*/

   /*------------ DEBUG PRINT --------------*/
      void debugPrint(String content, String debugMsg){
         if(DEBUGFLAG == 1)System.out.print(debugMsg + ": ");
         System.out.println(content);
      }
   /*------------ DEBUG PRINT --------------*/

   /*------------ GET new TEMP ---------------*/
      int getNewTemp(){
         tempCounter++;
         return tempCounter;
      }
   /*------------ GET new TEMP ---------------*/
/*----------------------------------------------------------------------------- */
/* - - - - - - - - - - - - - MICRO IR CUSTOM FUNCTIONS & VARS - - - - - - - - - */
/*----------------------------------------------------------------------------- */


   public String visit(NodeList n, String argu) {
      String _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public String visit(NodeListOptional n, String argu) {
      if ( n.present() ) {
         String _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public String visit(NodeOptional n, String argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public String visit(NodeSequence n, String argu) {
      String _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public String visit(NodeToken n, String argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public String visit(Goal n, String argu) {
      String _ret=null;

      /*----- First pass -----*/
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      /*----- First pass -----*/

      /*----- Extended classes -----*/
      checkCycle();
      extendClasses();
      allValidTypes();
      /*----- Extended classes -----*/

      //print();
      
      pass = 2;
      /*----- Third pass -----*/
      n.f0.accept(this, argu);
      MicroIRAllMethods();
      /*----- Third pass -----*/


      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public String visit(MainClass n, String argu) {
      /* MICRO IR */
         if(pass == 2){
            System.out.println("MAIN");
         }
      /* MICRO IR */

      String _ret=null;
      n.f0.accept(this, argu);
      String cls = n.f1.accept(this, argu);
      
      /* AddClass */
         if (pass == 0) {
            addClass(cls,null);
         }
      /* AddClass */

      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      n.f10.accept(this, argu);
      

      /* Add main method */
         if (pass == 0) {
            MethodMap object = new MethodMap();
            object.name = "main";
            object.parentClass = cls;
            Para p = new Para();
            p.type = "String[]";

            p.name = n.f11.accept(this, argu);

            object.parameters.add(p);
            object.retType = "void";
            addMethod(cls, object);
         }
      /* Add main method */

      n.f12.accept(this, argu);
      n.f13.accept(this, argu);
      n.f14.accept(this, argu);
      n.f15.accept(this, argu);
      n.f16.accept(this, argu);

      /* MICRO IR */
         if(pass == 2){
            System.out.println("END");
         }
      /* MICRO IR */

      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public String visit(TypeDeclaration n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public String visit(ClassDeclaration n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);

      String cls = 
      n.f1.accept(this, argu);

      currClass = cls;

      /* AddClass */
         if (pass == 0) {
            addClass(cls,null);
         }
      /* AddClass */

      n.f2.accept(this, argu);
      n.f3.accept(this, cls);//adding variables
      n.f4.accept(this, cls);//adding methods
      n.f5.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public String visit(ClassExtendsDeclaration n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);

      String cls = 
      n.f1.accept(this, argu);

      currClass = cls;

      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      
      /* AddClass */
         if (pass == 0) {
            addClass(cls,n.f3.f0.tokenImage);
         }
      /* AddClass */



      n.f4.accept(this, argu);
      n.f5.accept(this, cls);//adding variables
      n.f6.accept(this, cls);//adding methods
      n.f7.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public String visit(VarDeclaration n, String scope) {
      String _ret=null;

      String typeVar = 
      n.f0.accept(this, scope);
      n.f1.accept(this, scope);
      n.f2.accept(this, scope);

      /*---- Adding to the corresponding scope ----*/
         if (pass == 0) {
            if(flagVar == 0){//class variables
               ClassMap temp = AllClass.get(scope);
               addVarClass(n.f1.f0.tokenImage,typeVar,temp);
            }
            if(flagVar == 1){//method variables
               ClassMap  currC = AllClass.get(currClass);
               MethodMap temp  = currC.methods.get(scope);
               addVarMethod(n.f1.f0.tokenImage,typeVar,temp);
            }
         }
      /*---- Adding to the corresponding scope ----*/

      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public String visit(MethodDeclaration n, String pclass) {
      String _ret=null;

      n.f0.accept(this, pclass);

      String retType = n.f1.accept(this, pclass);// return type
      String name    = n.f2.accept(this, pclass);// method name
      
      currMethod = name;

      /*---------- PASS 0 ----------*/
         if (pass == 0) {
         /* Creating MethodMap */
            MethodMap meth = new MethodMap();
            meth.retType = retType;
            meth.name = name;
            meth.parentClass = pclass;
            meth.NODE = n;
         /* Creating MethodMap */

         /* Adding the method to Class*/
            addMethod(pclass,meth);
         /* Adding the method to Class*/
         }
      /*---------- PASS 0 ----------*/

      n.f3.accept(this, pclass);
      n.f4.accept(this, name);// parameters will be added
      n.f5.accept(this, pclass);
      n.f6.accept(this, pclass);

      flagVar = 1;
      n.f7.accept(this, name);// variables
      flagVar = 0;

      /*---------- PASS 2 ----------*/
         if ( pass == 2 ){/* MICRO IR */
            int methPsize = (((AllClass.get(currClass)).methods).get(currMethod)).parameters.size() + 1;
            System.out.println(currClass+"_NVK_"+currMethod+" ["+Integer.toString(methPsize)+"]");
            System.out.println("BEGIN");
            tempCounter = ((AllClass.get(currClass)).methods).get(currMethod).variables.size();
         }
      /*---------- PASS 2 ----------*/

      n.f8.accept(this, pclass);
      n.f9.accept(this, pclass);

      String returnedType = n.f10.accept(this, pclass);

      /*---------- PASS 2 ----------*/
         if(pass==2){
            debugPrint("RETURN TEMP "+ Integer.toString(tempCounter),"RETURNSTMT");
         }
      /*---------- PASS 2 ----------*/

      n.f11.accept(this, pclass);
      n.f12.accept(this, pclass);

      /*---------- PASS 2 ----------*/
         if(pass == 2){
            System.out.println("END");
            tempCounter = 0;
         }
      /*---------- PASS 2 ----------*/

      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public String visit(FormalParameterList n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public String visit(FormalParameter n, String m) {
      String _ret=null;


      String type = n.f0.accept(this, m);
      String name = n.f1.accept(this, m);

      /*---------- PASS 0 ----------*/
         if (pass == 0) {
         /*----- Getting Method to add para to -----*/
            ClassMap tmp = AllClass.get(currClass);
            MethodMap meth = tmp.methods.get(m);

            Para p = new Para();
            p.type = type;
            p.name = name;
         /*----- Getting Method to add para to -----*/  

         /*adding */
            meth.parameters.add(p);
            addVarMethod(p.name,p.type,meth);
         /*adding */
         }
      /*---------- PASS 0 ----------*/

      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public String visit(FormalParameterRest n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public String visit(Type n, String argu) {
      String _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public String visit(ArrayType n, String argu) {
      String _ret="int[]";
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public String visit(BooleanType n, String argu) {
      String _ret="boolean";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public String visit(IntegerType n, String argu) {
      String _ret="int";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | DoStatement()
    *       | PrintStatement()
    */
   public String visit(Statement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public String visit(Block n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public String visit(AssignmentStatement n, String argu) {
      String _ret=null;

      String var = 
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);

      String expType = 
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);

      /*------ MICRO IR ------*/
         if(pass == 2){
            int tempVar = getTempOfID(var);
            if(tempVar == -1){
               int tempOffset = getOffsetVar(var);
               debugPrint("HSTORE TEMP 0 "+Integer.toString(tempOffset)+" TEMP "+Integer.toString(tempCounter),"AssSTMT1");
            }
            else{
               debugPrint("MOVE TEMP "+Integer.toString(tempVar)+" TEMP "+Integer.toString(tempCounter),"AssSTMT2");
            }
         }
      /*------ MICRO IR ------*/
      
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public String visit(ArrayAssignmentStatement n, String argu) {
      String _ret=null;

      String var =
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);

      String expType1 =
      n.f2.accept(this, argu);
      int indexTemp = tempCounter;

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      String expType2 =
      n.f5.accept(this, argu);
      int rhsTemp = tempCounter;

      n.f6.accept(this, argu);

      /*------ MICRO IR ------*/
         if(pass == 2){
            int tempVar = getTempOfID(var);
            if(tempVar == -1){
               int tempOffset = getOffsetVar(var);
               tempCounter++;int arrTemp = tempCounter;
               debugPrint("HLOAD TEMP "+Integer.toString(tempCounter)+" TEMP 0 "+Integer.toString(tempOffset),"ArrAssSTMT1");
               debugPrint("MOVE TEMP "+Integer.toString(indexTemp)+" PLUS TEMP "+Integer.toString(indexTemp)+" 1","ArrAssSTMT1");
               debugPrint("MOVE TEMP "+Integer.toString(indexTemp)+" TIMES TEMP "+Integer.toString(indexTemp)+" 4","ArrAssSTMT1");
               tempCounter++;
               debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" PLUS TEMP "+Integer.toString(arrTemp)+" TEMP "+Integer.toString(indexTemp),"ArrAssSTMT1");
               debugPrint("HSTORE TEMP "+Integer.toString(tempCounter)+" 0 TEMP "+Integer.toString(rhsTemp),"ArrAssSTMT1");
            }
            else{
               debugPrint("MOVE TEMP "+Integer.toString(indexTemp)+" PLUS TEMP "+Integer.toString(indexTemp)+" 1","ArrAssSTMT1");
               debugPrint("MOVE TEMP "+Integer.toString(indexTemp)+" TIMES TEMP "+Integer.toString(indexTemp)+" 4","ArrAssSTMT2");
               tempCounter++;
               debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" PLUS TEMP "+Integer.toString(tempVar)+" TEMP "+Integer.toString(indexTemp),"ArrAssSTMT2");
               debugPrint("HSTORE TEMP "+Integer.toString(tempCounter)+" 0 TEMP "+Integer.toString(rhsTemp),"ArrAssSTMT2");
            }
         }
      /*------ MICRO IR ------*/

      return _ret; 
   }

   /**
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public String visit(IfStatement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public String visit(IfthenStatement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String expType = 
      n.f2.accept(this, argu);
      
      /*------ MICRO IR -------*/
         int exitLabel=-1;
         if(pass == 2){
            labelCounter++;
            exitLabel = labelCounter;
            debugPrint("CJUMP TEMP "+Integer.toString(tempCounter)+" L"+ Integer.toString(exitLabel),"IfThen2");
         }
      /*------ MICRO IR -------*/

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      /*------ MICRO IR -------*/
         if(pass == 2){
            debugPrint("L"+Integer.toString(exitLabel),"IfThenEND");
            debugPrint("NOOP","IfThenEND2");
         }
      /*------ MICRO IR -------*/

      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public String visit(IfthenElseStatement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String expType =
      n.f2.accept(this, argu);

      /*------ MICRO IR -------*/
         int thenLabel=-1;
         int elseLabel=-1;
         int exitLabel=-1;
         if(pass == 2){
            labelCounter++;
            elseLabel = labelCounter;
            debugPrint("CJUMP TEMP "+Integer.toString(tempCounter)+" L"+ Integer.toString(elseLabel),"IfThenElse2");
            labelCounter++;
            exitLabel = labelCounter;
         }
      /*------ MICRO IR -------*/

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      
      /* PASS 2 */
         if(pass==2) debugPrint("JUMP L"+Integer.toString(exitLabel),"IfThenElse3");

      n.f5.accept(this, argu);

      /* PASS 2 */
         if(pass==2) {debugPrint("L"+Integer.toString(elseLabel),"IfThenElse4");debugPrint("NOOP","__");}

      n.f6.accept(this, argu);

      /* PASS 2 */
         if(pass==2) {debugPrint("L"+Integer.toString(exitLabel),"IfThenElse5");debugPrint("NOOP","__");}

      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public String visit(WhileStatement n, String argu) {

      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);

      /*------ MICRO IR -------*/
         int startWhile = -1;
         if(pass==2){
            labelCounter++;
            startWhile = labelCounter;
            debugPrint("L"+Integer.toString(labelCounter),"While1");
            debugPrint("NOOP","While1(2)");
         }
      /*------ MICRO IR -------*/
         
      String expType =
      n.f2.accept(this, argu);
      
      /*------ MICRO IR -------*/
         int exitLabel=-1;
         if(pass == 2){
            labelCounter++;
            exitLabel = labelCounter;
            debugPrint("CJUMP TEMP "+Integer.toString(tempCounter)+" L"+ Integer.toString(exitLabel),"While2");
         }
      /*------ MICRO IR -------*/

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      
      /*------ MICRO IR -------*/
         if(pass == 2){
            debugPrint("JUMP L"+Integer.toString(startWhile),"WhileGotoStart");
            debugPrint("L"+Integer.toString(exitLabel),"WhileEND");
            debugPrint("NOOP","WhileEND2");
         }
      /*------ MICRO IR -------*/


      return _ret;
   }

   /**
    * f0 -> "do"
    * f1 -> Statement()
    * f2 -> "while"
    * f3 -> "("
    * f4 -> Expression()
    * f5 -> ")"
    * f6 -> ";"
    */
   public String visit(DoStatement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      
      /*------ MICRO IR -------*/
         int startWhile = -1;
         if(pass==2){
            labelCounter++;
            startWhile = labelCounter;
            debugPrint("L"+Integer.toString(labelCounter),"doWhile1");
            debugPrint("NOOP","doWhile1(2)");
         }
      /*------ MICRO IR -------*/
         

      n.f1.accept(this, argu);//Statement
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      String expType =
      n.f4.accept(this, argu);//expression

      /*------ MICRO IR -------*/
         int exitLabel=-1;
         if(pass == 2){
            labelCounter++;
            exitLabel = labelCounter;
            debugPrint("CJUMP TEMP "+Integer.toString(tempCounter)+" L"+ Integer.toString(exitLabel),"doWhile2");
            debugPrint("JUMP L"+Integer.toString(startWhile),"doWhile3");
            debugPrint("L"+Integer.toString(exitLabel),"doWhile4");
            debugPrint("NOOP","doWhile4(2)");
         }
      /*------ MICRO IR -------*/

      n.f5.accept(this, argu);
      n.f6.accept(this, argu);

      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public String visit(PrintStatement n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String expType =
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      /*------ MICRO IR ------*/
         if(pass == 2){
            System.out.println("PRINT TEMP "+Integer.toString(tempCounter));
         }
      /*------ MICRO IR ------*/


      return _ret;
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | AddExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public String visit(Expression n, String argu) {
      String _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public String visit(AndExpression n, String argu) {
      String _ret="boolean";

      String t1 = 
      n.f0.accept(this, argu);//exp1
      /*------------ FIRST EXP ------------*/
        int temp1 = tempCounter;
        int falseLabel = -1;
        if(pass ==2 ){
            labelCounter++;
            falseLabel = labelCounter;
            debugPrint("CJUMP TEMP "+Integer.toString(temp1)+ " L"+Integer.toString(falseLabel),"AND1");         
        }
      /*------------ FIRST EXP ------------*/

      n.f1.accept(this, argu);

      String t2 = 
      n.f2.accept(this, argu);//exp2
      /*------------ SECOND EXP ------------*/
        int temp2 = tempCounter;
        int exitLabel = -1;
        if(pass ==2 ){
            tempCounter++;
            debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" TEMP "+Integer.toString(temp2),"AND2");
            labelCounter++;
            exitLabel = labelCounter;
            debugPrint("JUMP L"+Integer.toString(exitLabel),"AND3");
            debugPrint("L"+Integer.toString(falseLabel),"AND4");
            debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" 0","AND5");
            debugPrint("L"+Integer.toString(exitLabel),"AND6");
            debugPrint("NOOP","AND7");
        }
      /*------------ SECOND EXP ------------*/

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   public String visit(OrExpression n, String argu) {
      String _ret="boolean";
     
      String t1 = 
      n.f0.accept(this, argu);
      /*------------ FIRST EXP ------------*/
        int temp1 = tempCounter;
        int falseLabel = -1;
        int trueLabel = -1;
        if(pass ==2 ){
            labelCounter++;
            falseLabel = labelCounter;
            debugPrint("CJUMP TEMP "+Integer.toString(temp1)+ " L"+Integer.toString(falseLabel),"OR1");  
            labelCounter++;
            trueLabel = labelCounter; 
            debugPrint("JUMP L"+Integer.toString(trueLabel),"OR2"); 
            debugPrint("L"+Integer.toString(falseLabel),"OR3");     
        }
      /*------------ FIRST EXP ------------*/

      n.f1.accept(this, argu);

      String t2 = 
      n.f2.accept(this, argu);
      /*------------ SECOND EXP ------------*/
        int temp2 = tempCounter;
        int exitLabel = -1;
        if(pass ==2 ){
            tempCounter++;
            debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" TEMP "+Integer.toString(temp2),"OR4");
            labelCounter++;
            exitLabel = labelCounter;
            debugPrint("JUMP L"+Integer.toString(exitLabel),"OR5");
            debugPrint("L"+Integer.toString(trueLabel),"OR6");
            debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" 1","OR7");
            debugPrint("L"+Integer.toString(exitLabel),"OR8");
            debugPrint("NOOP","OR9");
        }
      /*------------ SECOND EXP ------------*/

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   public String visit(CompareExpression n, String argu) {
      String _ret="boolean";
      
      String t1 = 
      n.f0.accept(this, argu);
      /* STORING TEMP OF EXP1 */
         int temp1 = tempCounter;

      n.f1.accept(this, argu);

      String t2 = 
      n.f2.accept(this, argu);
      /* STORING TEMP OF EXP2 */
         int temp2 = tempCounter;
      
      /*-------- EVALUATING <= --------*/
         if(pass==2){
            tempCounter++;
            debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" LE TEMP "+Integer.toString(temp1)+" TEMP "+Integer.toString(temp2),"LE"); 
         }
      /*-------- EVALUATING <= --------*/

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   public String visit(neqExpression n, String argu) {
      String _ret="boolean";

      String t1 = n.f0.accept(this, argu);
      /* STORING TEMP OF EXP1 */
         int temp1 = tempCounter;

      n.f1.accept(this, argu);

      String t2 = n.f2.accept(this, argu);
      /* STORING TEMP OF EXP2 */
         int temp2 = tempCounter;

      /*-------- EVALUATING != --------*/
         if(pass==2){
            tempCounter++;
            debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" NE TEMP "+Integer.toString(temp1)+" TEMP "+Integer.toString(temp2),"NE"); 
         }
      /*-------- EVALUATING != --------*/

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public String visit(AddExpression n, String argu) {
      String _ret="int";
      
      String t1 = n.f0.accept(this, argu);
      /* STORING TEMP OF EXP1 */
         int temp1 = tempCounter;

      n.f1.accept(this, argu);

      String t2 = n.f2.accept(this, argu);
      /* STORING TEMP OF EXP2 */
         int temp2 = tempCounter;

      /*-------- EVALUATING + --------*/
         if(pass==2){
            tempCounter++;
            debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" PLUS TEMP "+Integer.toString(temp1)+" TEMP "+Integer.toString(temp2),"PLUS"); 
         }
      /*-------- EVALUATING + --------*/

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public String visit(MinusExpression n, String argu) {
      String _ret="int";
      
      String t1 = n.f0.accept(this, argu);
      /* STORING TEMP OF EXP1 */
         int temp1 = tempCounter;

      n.f1.accept(this, argu);

      String t2 = n.f2.accept(this, argu);
      /* STORING TEMP OF EXP2 */
         int temp2 = tempCounter;

      /*-------- EVALUATING - --------*/
         if(pass==2){
            tempCounter++;
            debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" MINUS TEMP "+Integer.toString(temp1)+" TEMP "+Integer.toString(temp2),"MINUS"); 
         }
      /*-------- EVALUATING - --------*/

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public String visit(TimesExpression n, String argu) {
      String _ret="int";
      
      String t1 = n.f0.accept(this, argu);
      /* STORING TEMP OF EXP1 */
         int temp1 = tempCounter;

      n.f1.accept(this, argu);

      String t2 = n.f2.accept(this, argu);
      /* STORING TEMP OF EXP2 */
         int temp2 = tempCounter;

      /*-------- EVALUATING * --------*/
         if(pass==2){
            tempCounter++;
            debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" TIMES TEMP "+Integer.toString(temp1)+" TEMP "+Integer.toString(temp2),"TIMES"); 
         }
      /*-------- EVALUATING * --------*/

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   public String visit(DivExpression n, String argu) {
      String _ret="int";
      
      String t1 = n.f0.accept(this, argu);
      /* STORING TEMP OF EXP1 */
         int temp1 = tempCounter;

      n.f1.accept(this, argu);

      String t2 = n.f2.accept(this, argu);
      /* STORING TEMP OF EXP2 */ 
         int temp2 = tempCounter;

      /*-------- EVALUATING / --------*/
         if(pass==2){
            tempCounter++;
            debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" DIV TEMP "+Integer.toString(temp1)+" TEMP "+Integer.toString(temp2),"DIV"); 
         }
      /*-------- EVALUATING / --------*/

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public String visit(ArrayLookup n, String argu) {
      String _ret="int";

      String t1 = n.f0.accept(this, argu);
      /* STORING TEMP OF EXP1 */
         int tempExp1 = tempCounter;
      n.f1.accept(this, argu);

      String t2 = n.f2.accept(this, argu);
      /* STORING TEMP OF EXP2 */
         int tempExp2 = tempCounter;
      n.f3.accept(this, argu);

      /*------ MICRO IR ------*/
         if(pass == 2){
            debugPrint("MOVE TEMP "+Integer.toString(tempExp2)+" PLUS TEMP "+Integer.toString(tempExp2)+" 1","ArrLookup1");
            debugPrint("MOVE TEMP "+Integer.toString(tempExp2)+" TIMES TEMP "+Integer.toString(tempExp2)+" 4","ArrLookup1");
            tempCounter++;
            debugPrint("MOVE TEMP "+Integer.toString(tempCounter)+" PLUS TEMP "+Integer.toString(tempExp1)+" TEMP "+Integer.toString(tempExp2),"ArrLookup1");
            tempCounter++;
            debugPrint("HLOAD TEMP "+Integer.toString(tempCounter)+" TEMP "+Integer.toString(tempCounter-1)+" 0","ArrLookup2");
         }
      /*------ MICRO IR ------*/

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public String visit(ArrayLength n, String argu) {
      String _ret="int";
      String t1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      /*------ MICRO IR ------*/
         if(pass==2){
            tempCounter++;
            debugPrint("HLOAD TEMP "+Integer.toString(tempCounter)+" TEMP "+Integer.toString(tempCounter-1)+" 0","ArrLength");
         }
      /*------ MICRO IR ------*/

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public String visit(MessageSend n, String argu) {
      String _ret = null;
      String name =
      n.f0.accept(this, argu);

      /*------ Code generation ------ */
         int classTemp = -10;
         int methTableTemp = -10;
         if(pass == 2){
            tempCounter++;
            methTableTemp = tempCounter;
            classTemp = tempCounter-1;
            debugPrint("HLOAD TEMP "+Integer.toString((tempCounter))+" TEMP "+Integer.toString((classTemp))+" 0","messageSend1");
            /* FOR LOADING METHOD TABLE */
         }
      /*------ Code generation ------ */

      n.f1.accept(this, argu);
      String methName =
      n.f2.accept(this, null);

      /*------ Code generation ------ */
         int methTemp = -10;
         if(pass == 2){
            tempCounter++;
            methTemp = tempCounter;
            debugPrint("HLOAD TEMP "+Integer.toString((tempCounter))+" TEMP "+Integer.toString((methTableTemp))+" "+Integer.toString(getOffsetMethod(name,methName)),"messageSend2");
            /* FOR GETTING THE METHOD OFFSET */
         }
      /*------ Code generation ------ */

      n.f3.accept(this, argu);
      n.f4.accept(this, "getTYPE");
      n.f5.accept(this, argu);

      
      /*------ Code generation ------ */
         if(pass == 2){
            tempCounter++;
            System.out.print("MOVE TEMP "+Integer.toString((tempCounter))+" CALL TEMP "+Integer.toString((methTemp))+" ( TEMP "+Integer.toString(classTemp));
            
            for(int i=expListGlobal.size() - ((((AllClass.get(name)).methods).get(methName)).parameters).size();i<expListGlobal.size();i++){
               System.out.print(" TEMP "+expListGlobal.get(i));
            }
            Vector<String> tempExpList = new Vector<String>();
            for(int i=0;i<expListGlobal.size()-((((AllClass.get(name)).methods).get(methName)).parameters).size();i++){
               tempExpList.add(expListGlobal.get(i));
            }
            expListGlobal.clear();
            expListGlobal = tempExpList;
            debugPrint(" )"," messageSend3");
            ClassMap cls = getClass(name);
            _ret=cls.methods.get(methName).retType;
            /* FOR GETTING THE METHOD OFFSET */
         }
      /*------ Code generation ------ */

      return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public String visit(ExpressionList n, String argu) {
      String _ret=null;
      String expType =
      n.f0.accept(this, argu);
      int temp1 = tempCounter;
      /*---- Keeping track of Temp in explist ----*/
         if(pass==2) expListGlobal.add(Integer.toString((temp1)));
      /*---- Keeping track of Temp in explist ----*/

      n.f1.accept(this, argu);


      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public String visit(ExpressionRest n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      String expType =
      n.f1.accept(this, argu);      

      /*---- Keeping track of Temp in explist ----*/
         if(pass==2) expListGlobal.add(Integer.toString((tempCounter)));
      /*---- Keeping track of Temp in explist ----*/

      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public String visit(PrimaryExpression n, String argu) {
      String _ret = null;
      if(pass == 2){
         _ret = n.f0.accept(this, "TEMP");         
      }
      else{
         _ret = n.f0.accept(this, "getTYPE");
      }
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public String visit(IntegerLiteral n, String argu) {
      String _ret="int";
      n.f0.accept(this, argu);
      if(pass == 2){
         tempCounter++;
         debugPrint("MOVE TEMP "+Integer.toString((tempCounter+0))+" "+n.f0.tokenImage,"intLit");
      }
      return _ret;
   }

   /**
    * f0 -> "true"
    */
   public String visit(TrueLiteral n, String argu) {
      String _ret="boolean";
      n.f0.accept(this, argu);
      if(pass == 2){
         tempCounter++;
         debugPrint("MOVE TEMP "+Integer.toString((tempCounter+0))+" 1","BoolTrue");
      }
      return _ret;
   }

   /**
    * f0 -> "false"
    */
   public String visit(FalseLiteral n, String argu) {
      String _ret="boolean";
      n.f0.accept(this, argu);
      if(pass == 2){
         tempCounter++;
         debugPrint("MOVE TEMP "+Integer.toString((tempCounter+0))+" 0","BoolFalse");
      }
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public String visit(Identifier n, String argu) {
      String _ret = n.f0.tokenImage;
      n.f0.accept(this, argu);
      if(argu!=null){
         if (argu.equals("getTYPE") && pass == 1){
            _ret = getType(_ret);
         }
         if(pass == 2 && argu.equals("TEMP")){
            tempCounter++;
            if(getTempOfID(_ret) == -1){
               debugPrint("HLOAD TEMP "+Integer.toString((tempCounter+0))+" TEMP 0 "+getOffsetVar(_ret),"identifier1");
            }
            else{
               debugPrint("MOVE TEMP "+Integer.toString((tempCounter+0))+" TEMP "+Integer.toString(getTempOfID(_ret)),"identifier2");
            }
            _ret = getType(n.f0.tokenImage);
            return _ret;
         }
         if(pass == 2 && argu.equals("NEW")){
            _ret = n.f0.tokenImage;
         }

      }
      
      return _ret;
   }

   /**
    * f0 -> "this"
    */
   public String visit(ThisExpression n, String argu) {
      String _ret = currClass;
      n.f0.accept(this, argu);
      if(pass == 2 && argu.equals("TEMP")){
         tempCounter++;
         debugPrint("MOVE TEMP "+Integer.toString((tempCounter+0))+" TEMP 0","thisExp");
      }
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public String visit(ArrayAllocationExpression n, String argu) {
      String _ret="int[]";
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String t = 
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      /*------ ARR INITIALIZE -------*/
         int returnTemp = -1;
         int startWhile = -1;
         int exitLabel=-1;
         if(pass == 2){
            int size = tempCounter;
            tempCounter++;
            int sizeTemp = tempCounter;
            debugPrint("MOVE TEMP "+Integer.toString((sizeTemp))+" PLUS TEMP "+Integer.toString((size))+" 1","newArrAlloc1"); 
            debugPrint("MOVE TEMP "+Integer.toString((sizeTemp))+" TIMES TEMP "+Integer.toString(sizeTemp)+" 4","newArrAlloc1");
            tempCounter++;
            debugPrint("MOVE TEMP "+Integer.toString((tempCounter))+" HALLOCATE TEMP "+Integer.toString((sizeTemp)),"newArrAlloc2");
            returnTemp = tempCounter;

            debugPrint("HSTORE TEMP "+Integer.toString((returnTemp))+" 0 TEMP "+Integer.toString(size),"newArrAlloc4");
            
            tempCounter++;
            int indexTemp = tempCounter;
            debugPrint("MOVE TEMP "+Integer.toString((indexTemp))+" 4","newArrAlloc3");
            
            labelCounter++;
            startWhile = labelCounter;
            debugPrint("L"+Integer.toString(labelCounter),"newArrAlloc4");
            labelCounter++;
            exitLabel = labelCounter;

            tempCounter++;
            debugPrint("MOVE TEMP "+Integer.toString((tempCounter))+" LE TEMP "+Integer.toString((indexTemp))+" TEMP "+Integer.toString((sizeTemp)),"newArrAlloc4");
            debugPrint("CJUMP TEMP "+Integer.toString(tempCounter)+" L"+ Integer.toString(exitLabel),"newArrAlloc4");

            tempCounter++;
            int zeroTemp = tempCounter;
            debugPrint("MOVE TEMP "+Integer.toString(zeroTemp)+" 0","newArrAlloc4");

            tempCounter++;
            int accessTemp = tempCounter;
            debugPrint("MOVE TEMP "+Integer.toString((accessTemp))+" PLUS TEMP "+Integer.toString((returnTemp))+" TEMP "+Integer.toString((indexTemp)),"newArrAlloc4");
            debugPrint("HSTORE TEMP "+Integer.toString((accessTemp))+" 0 TEMP "+Integer.toString((zeroTemp)),"newArrAlloc4");
            
            debugPrint("MOVE TEMP "+Integer.toString((indexTemp))+" PLUS TEMP "+Integer.toString((indexTemp))+" 4","newArrAlloc4");
            debugPrint("JUMP L"+Integer.toString(startWhile),"newArrAlloc4");

            debugPrint("L"+Integer.toString(exitLabel),"newArrAlloc4");
            
            tempCounter++;
            debugPrint("MOVE TEMP "+Integer.toString((tempCounter))+" TEMP "+Integer.toString((returnTemp)),"newArrAlloc3");
         }
      /*------ MICRO IR -------*/

      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public String visit(AllocationExpression n, String argu) {
      n.f0.accept(this, argu);
      String _ret = n.f1.accept(this, "NEW");
      
      if(pass == 2){
         tempCounter++;
         createNewTable(_ret);
         debugPrint("MOVE TEMP "+Integer.toString((tempCounter+0))+" TEMP "+Integer.toString((tempCounter+1)),"newALLOC");
      }
      
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public String visit(NotExpression n, String argu) {
      String _ret="boolean";
      n.f0.accept(this, argu);
      String t = 
      n.f1.accept(this, argu);

      if(pass==1 && !(t.equals("boolean"))){
         throwTypeError("! exp");
      }

      if(pass==2){
         tempCounter++;
         debugPrint("MOVE TEMP "+Integer.toString((tempCounter))+" 1","NOT1");
         tempCounter++;
         debugPrint("MOVE TEMP "+Integer.toString((tempCounter))+" MINUS TEMP "+Integer.toString(tempCounter-1)+" TEMP "+Integer.toString((tempCounter-2)),"NOT2");
      }

      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public String visit(BracketExpression n, String argu) {
      n.f0.accept(this, argu);
      String _ret = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      if(pass==2){
         tempCounter++;
         debugPrint("MOVE TEMP "+Integer.toString((tempCounter))+" TEMP "+Integer.toString((tempCounter-1)),"bracketExp");
         //_ret = "TEMP "+Integer.toString((tempCounter+0));
      }
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( IdentifierRest() )*
    */
   public String visit(IdentifierList n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public String visit(IdentifierRest n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

}